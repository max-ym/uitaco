//! Graphical User Interface for Rust using HTML code to create visual components and to build
//! UI from them. Also, attachment of CSS and JS is possible. This library
//! also uses `webview` crate to display the content and control the page as components
//! get modified by the user actions or by Rust back-end.

#[macro_use]
extern crate typed_html;
extern crate web_view;
extern crate webview_sys;
extern crate serde_derive;
extern crate serde_json;
pub extern crate htmldom_read;
extern crate owning_ref;
extern crate rsgen;
extern crate base64;
extern crate uitaco_derive;

pub use uitaco_derive::*;

use serde_derive::{Deserialize};
use web_view::{Content, WVResult};
use std::sync::{Arc, RwLock, mpsc, Weak, Mutex};
use std::collections::{HashMap, HashSet};
use crate::component::{ComponentBase, ComponentHandle, ComponentId, Component, Container, AddComponentError, ChildrenLogic, ChildrenLogicAddError, ClassHandle, Class};
use typed_html::dom::DOMTree;
use crate::tags::{Element, TagName};
use htmldom_read::Node;
use std::fmt::{Debug, Formatter};
pub use owning_ref::{RwLockReadGuardRef, RwLockWriteGuardRefMut};
use std::thread;
use std::thread::JoinHandle;

/// Components allow to build user interface using repeated patterns with binding to elements.
/// This allows to speed up building of UI. Binding allows to easily access contents from Rust.
pub mod component;

/// Tags that are used to access corresponding information of the page.
pub mod tags;

/// Events that can be generated by tags.
pub mod events;

/// Allows to format JS-strings prefixing quote signs if present with `\`.
/// For example string `elementById("")` will be transformed to `elementById(\"\")`.
pub fn js_prefix_quotes(s: &str) -> String {
    let mut quote_count = 0;
    for c in s.chars() {
        if c == '\'' || c == '"' {
            quote_count += 1;
        }
    }

    let mut new_s = String::with_capacity(s.len() + quote_count);
    for c in s.chars() {
        if c == '\'' || c == '"' {
            new_s.push('\\');
        }
        new_s.push(c);
    }

    new_s
}

/// Root component must be added first.
const ROOT_COMPONENT_ID: ComponentId = 0;

type UserData = Vec<(String, String)>;
type WebView<'a> = web_view::WebView<'a, UserData>;
type Callback = Fn(ViewWrap, String);
type RequestId = usize;
type CallbackId = usize;
type ViewId = usize;
pub type ViewHandle = Arc<ViewTuple>;
pub type ViewWeak = Weak<ViewTuple>;
pub type ViewGuard<'a> = RwLockReadGuardRef<'a, View>;
pub type ViewGuardMut<'a> = RwLockWriteGuardRefMut<'a, View>;

/// Main structs that are used to control WebView backend, Uitaco structs and send commands
/// between Uitaco and WebView.
#[derive(Debug)]
pub struct ViewTuple {
    view: RwLock<View>,
    sender: Mutex<mpsc::Sender<ViewCmd>>,
}

/// Used with RwLock. Marker. Whether WebView is accessed in read or write modes.
#[derive(Debug, Clone)]
pub struct WebViewAccess;

/// Thread-send impl for WebView
struct WebViewSend {
    wv: WebView<'static>
}
unsafe impl Send for WebViewSend {}
unsafe impl Sync for WebViewSend {}

/// Command that can be sent to View.
#[derive(Debug)]
pub enum ViewCmd {

    /// Evaluate given JS code.
    Eval(Option<mpsc::Sender<WVResult>>, String),
    InjectCss(String),
    Exit,
}

/// Wrapped instance of WebView. Also is connected to thread that runs GUI on that instance.
/// Is used to dispatch commands over GUI.
pub struct View {
    id: ViewId,

    // After initialization is always set to Some.
    this: Option<ViewWeak>,

    next_component_id: ComponentId,
    components: HashMap<ComponentId, Arc<RwLock<Box<dyn Component>>>>,

    next_callback_id: CallbackId,
    callbacks: HashMap<CallbackId, &'static dyn Fn(ViewWrap, String)>,

    next_request_id: RequestId,
    requests: HashMap<RequestId, mpsc::Sender<ResponseValue>>,

    thread: Option<JoinHandle<()>>,
}

/// Wrap over view handle to make access easier.
#[derive(Clone, Debug)]
pub struct ViewWrap {
    inner: ViewHandle,
}

unsafe impl Sync for View {}
unsafe impl Send for View {}

#[derive(Clone, Debug)]
pub struct ViewBuilder {
    debug: bool,
    fullscreen: bool,
    resizable: bool,
    width: usize,
    height: usize,
    title: Option<String>,
}

#[derive(Debug)]
struct RequestBuilder {
    view: ViewWrap,
    id: RequestId,
    js: Option<String>,
    rx: mpsc::Receiver<ResponseValue>,
    tx: mpsc::Sender<ResponseValue>,
}

#[derive(Debug)]
pub struct RootComponent {
    base: ComponentBase,
}

impl Clone for WebViewSend {

    fn clone(&self) -> Self {
        let wv: WebView = unsafe { std::mem::transmute_copy(&self.wv) };
        WebViewSend { wv }
    }
}

impl Debug for View {

    fn fmt(&self, fmt: &mut Formatter) -> std::fmt::Result {
        #[derive(Debug)]
        struct DebuggableView<'a> {
            id: ViewId,

            next_component_id: ComponentId,
            components: &'a HashMap<ComponentId, Arc<RwLock<Box<dyn Component>>>>,

            next_callback_id: CallbackId,
            callbacks: HashSet<CallbackId>,

            next_request_id: RequestId,
            requests: &'a HashMap<RequestId, mpsc::Sender<ResponseValue>>,
        };

        let callbacks = {
            let mut set
                = HashSet::with_capacity(self.callbacks.len());

            for (i, _) in &self.callbacks {
                set.insert(*i);
            }

            set
        };

        let s = DebuggableView {
            id: self.id,

            next_component_id: self.next_component_id,
            components: &self.components,

            next_callback_id: self.next_callback_id,
            callbacks,

            next_request_id: self.next_request_id,
            requests: &self.requests,
        };

        s.fmt(fmt)
    }
}

impl View {

    /// Get new builder to help creating view.
    pub fn new_builder() -> ViewBuilder {
        ViewBuilder {
            debug: true,
            fullscreen: false,
            resizable: true,
            width: 640,
            height: 480,
            title: None,
        }
    }

    /// Create new view. This opens a WebView window.
    pub fn new_from_builder(builder: ViewBuilder) -> ViewWrap {
        let mut my_builder = web_view::builder();
        my_builder.debug = builder.debug;
        my_builder.resizable = builder.resizable;
        my_builder.title = "Unnamed Uitaco";
        my_builder.width = builder.width as _;
        my_builder.height = builder.height as _;

        let uitaco_body_id = "uitacoBody";

        let content = {
            let uitaco_body_id = typed_html::types::Id::new(uitaco_body_id);
            let i: DOMTree<String> = html!(
                <html>
                <head><title /></head>
                <body class=component::COMPONENT_MARK id=uitaco_body_id></body>
                </html>
            );
            i.to_string()
        };

        my_builder.content = Some(Content::Html(content.clone()));

        let (tx, rx) = mpsc::channel();
        let view = View {
            id: 0,

            this: None,

            next_component_id: 0,
            components: Default::default(),

            next_request_id: 0,
            requests: Default::default(),

            next_callback_id: 0,
            callbacks: Default::default(),

            thread: None,
        };
        let tuple = ViewTuple {
            view: RwLock::new(view),
            sender: Mutex::new(tx),
        };

        // Create arcs for wrap and access from new webview thread.
        let tuple = Arc::new(tuple);

        { // Save self-pointer.
            let mut view = tuple.view.write().unwrap();
            view.this = Some(Arc::downgrade(&tuple));
        }

        let wrap = ViewWrap {
            inner: tuple.clone(),
        };

        // Create and add root component.
        let mut classes = Class::all_from_html(&content);
        let body_class = classes.remove(uitaco_body_id).unwrap();
        let mut body_builder = body_class.into_builder();
        body_builder.element_by_id_mut(uitaco_body_id).unwrap().use_initial_name();
        let body_component = body_builder.build(wrap.clone());
        let root_component = RootComponent { base: body_component };
        {
            let mut guard = wrap.inner.view.write().unwrap();
            let data = RwLock::new(Box::new(root_component) as _);
            guard.components.insert(ROOT_COMPONENT_ID, Arc::new(data));
            guard.next_component_id += 1;
        }

        // Thread where WebView will live.
        let arc2 = tuple.clone();
        let thread = thread::spawn(move || {
            let webview = my_builder
                .invoke_handler(move |_, arg| {
                    let mut view = arc2.view.write().unwrap();
                    view.handler(arg)
                })
                .user_data(UserData::new())
                .build().unwrap();

            let transfer = WebViewSend { wv: webview };
            let arc = Arc::new(RwLock::new(transfer));
            let arc2 = arc.clone();

            // Thread to process cmds and dispatch them.
            thread::spawn(move || {
                loop {
                    let result = rx.recv();
                    if let Err(_) = result {
                        // Nothing.
                    } else if let Ok(cmd) = result {
                        let handle = {
                            arc.read().unwrap().wv.handle()
                        };
                        use ViewCmd::*;
                        match cmd {
                            Eval(sender, st) => {
                                let arc = arc.clone();
                                handle.dispatch(move |_| {
                                    let mut lock
                                        = arc.write().unwrap();
                                    let wv = &mut lock.wv;

                                    let result = wv.eval(&st);
                                    if let Some(sender) = sender {
                                        sender.send(result).unwrap();
                                    }

                                    Ok(())
                                }).unwrap();
                            },
                            InjectCss(st) => {
                                let arc = arc.clone();
                                handle.dispatch(move |_| {
                                    let mut lock = arc.write().unwrap();
                                    let wv = &mut lock.wv;
                                    let result = wv.inject_css(&st);
                                    if result.is_err() {
                                        // Nothing.
                                    }

                                    Ok(())
                                }).unwrap();
                            },
                            Exit => break, // TODO
                        }
                    }
                }
            });

            // Unleash rwlock because closures are blocking it too. Still it is safe
            // to use lock as closures will access it only after `step` fn calls them.
            // Which already will make all the changes needed and will not need access to lock
            // by the time closures are run.
            let wv = unsafe {
                let mut lock = arc2.write().unwrap();
                &mut *(&mut *lock as *mut WebViewSend)
            };
            loop {
                match wv.wv.step() {
                    Some(_) => (),
                    None => break,
                }
            }
        });

        wrap.inner.view.write().unwrap().thread = Some(thread);
        wrap
    }

    /// Get new handle on this view.
    pub fn handle(&self) -> ViewWrap {
        ViewWrap { inner: self.this.as_ref().unwrap().upgrade().unwrap() }
    }

    /// Get access to root component Arc.
    pub fn root_component(&self) -> ComponentHandle {
        ComponentHandle::new(self.handle(), ROOT_COMPONENT_ID)
    }

    /// Add new component to the interface and get a handle to it.
    fn add_component(&mut self, component: Box<dyn Component>) -> ComponentHandle {
        let (id, arc) = {
            let id = self.next_component_id;
            self.next_component_id += 1;

            let arc = Arc::new(RwLock::new(component));
            self.components.insert(id, arc.clone());
            (id, arc)
        };

        unsafe { ComponentHandle::new_unsafe(self.handle(), id, arc) }
    }

    /// Try removing component from the interface. If it does not exist None is returned.
    /// Also, it may still be in use though it will still be removed from the interface
    /// and all new changes to the component will be therefore ignored.
    fn remove_component(&mut self, handle: &ComponentHandle) -> Option<()> {
        let option = self.components.remove(&handle.id());
        if let Some(_) = option {
            Some(())
        } else {
            None
        }
    }

    fn new_request(&mut self) -> RequestBuilder {
        let id = {
            let id = self.next_request_id;
            self.next_request_id += 1;
            id
        };

        RequestBuilder::new(self.handle(), id)
    }

    /// Add new callback. Get descriptor of newly registered callback.
    fn add_callback(&mut self, f: Box<&'static Callback>) -> CallbackId {
        let id = self.next_callback_id;
        self.callbacks.insert(id, *f);
        self.next_callback_id += 1;
        id
    }

    /// Remove previously registered callback.
    ///
    /// # Panics
    /// This function will panic if callback is not present.
    fn remove_callback<'a, 'b>(&'a mut self, id: CallbackId) -> &'b Callback {
        self.callbacks.remove(&id).unwrap()
    }

    /// Find callback with given id.
    fn callback<'a, 'b>(&'a self, id: CallbackId) -> Option<Box<&'b Callback>> {
        if let Some(f) = self.callbacks.get(&id) {
            Some(Box::new(f.clone()))
        } else {
            None
        }
    }

    /// Function that handles events from JavaScript.
    fn handler(&mut self, arg: &str) -> web_view::WVResult {
        use InCmd::*;

        match serde_json::from_str(arg).unwrap() {
            Callback {
                descriptor,
                args,
            } => {
                if let Some(f) = self.callback(descriptor) {
                    let s = self.handle();
                    f(s, args);
                }
            },

            ExistenceTest {
                request,
                found,
            } => {
                self.respond(request, ResponseValue::Bool(found));
            },

            Attribute {
                request,
                value,
            } => {
                self.respond(request, ResponseValue::Str(value));
            },
        }

        Ok(())
    }

    /// Remove previously registered request by id if any. Function returns a sender
    /// that was to be used to wake up the waiting function.
    fn remove_request(&mut self, id: RequestId) -> Option<mpsc::Sender<ResponseValue>> {
        self.requests.remove(&id)
    }

    /// Save request response. Remove request from waiting list and wake up the waiter.
    fn respond(&mut self, id: RequestId, val: ResponseValue) {
        if let Some(r) = self.requests.remove(&id) {
            let _result = r.send(val);
            // TODO use result
        }
    }

    /// Wait until this view finishes it's execution.
    pub fn wait_to_finish(&mut self) -> JoinHandle<()> {
        let mut thread = None;
        std::mem::swap(&mut thread, &mut self.thread);
        thread.unwrap()
    }
}

impl ViewWrap {

    pub fn inner(&self) -> &ViewHandle {
        &self.inner
    }

    /// Get access to sender of web view commands.
    pub fn webview_cmd(&self) -> &Mutex<mpsc::Sender<ViewCmd>> {
        &self.inner.sender
    }

    pub fn new_builder() -> ViewBuilder {
        View::new_builder()
    }

    pub fn new_from_builder(builder: ViewBuilder) -> ViewWrap {
        View::new_from_builder(builder)
    }

    /// Get new handle on this view.
    pub fn handle(&self) -> ViewWrap {
        let view = self.inner.view.read().unwrap();
        view.handle()
    }

    /// Get access to root component Arc.
    pub fn root_component(&self) -> ComponentHandle {
        let view = self.inner.view.read().unwrap();
        view.root_component()
    }

    /// Add new callback. Get descriptor of newly registered callback.
    fn add_callback(&mut self, f: Box<&'static Callback>) -> CallbackId {
        let mut view = self.inner.view.write().unwrap();
        view.add_callback(f)
    }

    /// Remove previously registered callback.
    ///
    /// # Panics
    /// This function will panic if callback is not present.
    fn remove_callback<'a, 'b>(&'a mut self, id: CallbackId) -> &'b Callback {
        let mut view = self.inner.view.write().unwrap();
        view.remove_callback(id)
    }

    /// Find callback with given id.
    fn callback<'a, 'b>(&'a self, id: CallbackId) -> Option<Box<&'b Callback>> {
        let view = self.inner.view.read().unwrap();
        view.callback(id)
    }

    fn new_request(&mut self) -> RequestBuilder {
        let mut view = self.inner.view.write().unwrap();
        view.new_request()
    }

    /// Inject styles to the view.
    pub fn inject_css(&self, css: String) {
        self.inner.sender.lock().unwrap().send(ViewCmd::InjectCss(css)).unwrap();
    }

    /// Run given JS code and wait for result.
    pub fn eval_wait(&self, js: String) -> WVResult {
        let (tx, rx) = mpsc::channel();
        self.inner.sender.lock().unwrap().send(ViewCmd::Eval(Some(tx), js)).unwrap();
        let recv = rx.recv().unwrap();
        recv
    }

    /// Run given JS code without waiting for result.
    pub fn eval(&self, js: String) {
        self.inner.sender.lock().unwrap().send(ViewCmd::Eval(None, js)).unwrap();
    }

    pub fn wait_to_finish(&self) {
        // Do not hold the lock just to wait view to finish as something else may need to
        // acquire the lock until then.
        let join = unsafe {
            let mut lock = self.inner.view.write().unwrap();
            let view = &mut *(&mut *lock as *mut View);
            view.wait_to_finish()
        };
        join.join().unwrap();
    }
}

impl ViewBuilder {

    pub fn debug(mut self, debug: bool) -> Self {
        self.debug = debug;
        self
    }

    pub fn fullscreen(mut self, fullscreen: bool) -> Self {
        self.fullscreen = fullscreen;
        self
    }

    pub fn resizable(mut self, resizable: bool) -> Self {
        self.resizable = resizable;
        self
    }

    pub fn size(mut self, width: usize, height: usize) -> Self {
        self.width = width;
        self.height = height;
        self
    }

    pub fn title(mut self, title: String) -> Self {
        self.title = Some(title);
        self
    }

    pub fn build(self) -> ViewWrap {
        View::new_from_builder(self)
    }
}

impl RequestBuilder {

    fn new(view: ViewWrap, id: RequestId) -> Self {
        let (tx, rx) = mpsc::channel();
        RequestBuilder {
            view,
            id,
            tx,
            rx,
            js: None,
        }
    }

    pub fn id(&self) -> RequestId {
        self.id
    }

    /// Attach JavaScript code to be run.
    pub fn attach_js(mut self, js: String) -> Self {
        self.js = Some(js);
        self
    }

    /// Evaluate the request.
    pub fn eval(self) -> mpsc::Receiver<ResponseValue> {
        let js = self.js.unwrap();
        let id = self.id;
        let view_wrap = self.view;

        // Insert request callback.
        {
            let mut view = view_wrap.inner().view.write().unwrap();
            // Save the sender to the view so callback could send the value to listener.
            view.requests.insert(id, self.tx);
        }
        let err = {
            // Must be called with unlocked View because it locks the View.
            view_wrap.eval_wait(js).is_err()
        };
        if err {
            // Evaluation failed so response will never arrive. Delete the entry.
            let mut view = view_wrap.inner().view.write().unwrap();
            view.remove_request(id);
        }

        self.rx
    }

    /// Attach this JavaScript code and evaluate it.
    pub fn run(self, js: String) -> mpsc::Receiver<ResponseValue> {
        self.attach_js(js).eval()
    }
}

impl Element for RootComponent {

    fn tag_name(&self) -> TagName {
        self.base.tag_name()
    }

    fn id(&self) -> &String {
        self.base.id()
    }

    fn view(&self) -> &ViewWrap {
        self.base.view()
    }

    fn view_mut(&mut self) -> &mut ViewWrap {
        self.base.view_mut()
    }
}

impl Container for RootComponent {

    fn add_component(&mut self, component: Box<dyn Component>)
            -> Result<ComponentHandle, AddComponentError> {
        let html = component.generated_html();
        let id = self.name();

        let js = format!("\
            var i = document.getElementById('{}');
            i.innerHTML += '{}';
        ", id, html.to_string());

        let result = self.base.add_component(component);
        if let Err(e) = result {
            return Err(e);
        }
        self.view_mut().eval(js);
        Ok(result.unwrap())
    }

    fn remove_component(&mut self, component: &ComponentHandle) -> Option<()> {
        let result = self.base.remove_component(component);
        if let Some(_) = result {
            let js = format!("\
                var i = document.getElementById('{}');
                i.outerHTML = '';
            ", component.read().as_owner().name());
            self.view_mut().eval(js);
            Some(())
        } else {
            None
        }
    }

    fn has_component(&self, component: &ComponentHandle) -> bool {
        self.base.has_component(component)
    }
}

impl ChildrenLogic for RootComponent {
    // Root component only accepts components.

    fn add_child(&mut self, child: Box<Element>) -> Result<(), ChildrenLogicAddError> {
        Err(ChildrenLogicAddError::UnexpectedChild(child))
    }

    fn remove_child(&mut self, _child: &str) -> Option<Box<dyn Element>> {
        None
    }

    fn contains_child(&self, _child: &str) -> bool {
        false
    }
}

impl Component for RootComponent {

    fn generated_html(&self) -> &Node {
        self.base.generated_html()
    }

    fn elements(&self) -> &HashMap<String, Box<Element>> {
        self.base.elements()
    }

    fn element_by_origin(&self, id: &str) -> Option<&Box<Element>> {
        self.base.element_by_origin(id)
    }

    fn name(&self) -> &String {
        self.base.name()
    }

    fn self_element(&self) -> &Box<Element> {
        self.base.self_element()
    }

    fn components(&self) -> &HashSet<ComponentHandle> {
        self.base.components()
    }

    fn class(&self) -> &ClassHandle {
        self.base.class()
    }
}

/// Command that can be received from JavaScript front-end.
#[derive(Deserialize, Clone, Debug)]
#[serde(tag = "incmd", rename_all = "camelCase")]
enum InCmd {

    /// Some event triggered callback. Passed arguments are stored in JSON format.
    /// Descriptor of callback function is used to identify which registered callback should be
    /// called.
    Callback {
        descriptor: usize,
        args: String,
    },

    /// Response command for a test whether some element still exists.
    ExistenceTest {
        request: RequestId,
        found: bool,
    },

    /// Response to attribute value request.
    Attribute {
        request: RequestId,
        value: String,
    },
}

/// Value received from JavaScript front-end.
enum ResponseValue {
    Bool(bool),
    Str(String)
}
